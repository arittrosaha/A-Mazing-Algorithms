{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./generators/dfs.js","webpack:///./main.js","webpack:///./setup/cell.js","webpack:///./setup/grid.js","webpack:///./solvers/bfs.js","webpack:///./solvers/dfs.js","webpack:///./solvers/human.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;ACnEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACxHA;AAAA;AACA;AACA;AACkB;;AAElB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;ACvBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;ACpHA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACnCe;;AAEf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;;;;;ACjHe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACpGe;;AAEf;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./main.js\");\n","import dfsSolve from '../solvers/dfs.js';\nimport bfsSolve from '../solvers/bfs.js';\nimport HumSolve from '../solvers/human.js';\n\nexport default function dfsGen (grid, width) {\n  const easyButton = document.getElementById('easy');\n  easyButton.disabled = true;\n  const mediumButton = document.getElementById('medium');\n  mediumButton.disabled = true;\n  const hardButton = document.getElementById('hard');\n  hardButton.disabled = true;\n\n  const dfsSolButton = document.getElementById('dfs-sol');\n  dfsSolButton.disabled = true;\n\n  const bfsSolButton = document.getElementById('bfs-sol');\n  bfsSolButton.disabled = true;\n\n  const humSolButton = document.getElementById('hum-sol');\n  humSolButton.disabled = true;\n\n  if (window.humanCallback) {\n    document.removeEventListener('keydown', window.humanCallback);\n  }\n\n\n  const stack = [];\n\n  const mC = document.getElementById('myCanvas');\n  const cWidth = mC.width;\n\n  const cols = Math.floor(cWidth/width);\n\n  let current = grid[0];\n  current.highlight('yellow');\n  current.visited = true;\n\n  const interval =  setInterval( () => {\n    current.show();\n\n    const neighbours = current.neighbours(\"visited\");\n    const next = selectNeighbour(neighbours);\n    if (next) {\n      next.visited = true;\n      next.parent = current;\n      stack.push(current);\n      removeWalls(current, next);\n      current.show();\n      next.show();\n      next.highlight('yellow');\n      current = next;\n    } else if (stack.length > 0){\n      current = stack.pop();\n      current.highlight('yellow');\n    }\n\n    if (current === grid[0]) {\n      clearInterval(interval);\n      current.show();\n\n      const min = grid.length-cols;\n      const max = grid.length-1;\n      const targetIdx = getRandomIntInclusive(min, max);\n      grid[targetIdx].target = true;\n      grid[targetIdx].show('lightskyblue');\n      grid[targetIdx].highlight('lightskyblue');\n\n      dfsSolButton.disabled = false;\n      dfsSolButton.onclick = function() {\n        dfsSolve(grid);\n      };\n\n      bfsSolButton.disabled = false;\n      bfsSolButton.onclick = function() {\n        bfsSolve(grid);\n      };\n\n      humSolButton.disabled = false;\n      humSolButton.onclick = function() {\n        new HumSolve(grid);\n      };\n\n      easyButton.disabled = false;\n      mediumButton.disabled = false;\n      hardButton.disabled = false;\n    }\n  }, 0);\n}\n\nfunction selectNeighbour (neighbours) {\n  if (neighbours.length > 0) {\n    const random = getRandomIntInclusive(0, neighbours.length-1);\n    return neighbours[random];\n  }\n}\n\nfunction removeWalls(c, n) {\n  const x = c.i - n.i;\n  const y = c.j - n.j;\n\n  if (x === -1) {\n    c.walls[1] = false;\n    n.walls[3] = false;\n  } else if (x === 1) {\n    c.walls[3] = false;\n    n.walls[1] = false;\n  }\n\n  if (y === -1) {\n    c.walls[2] = false;\n    n.walls[0] = false;\n  } else if (y === 1) {\n    c.walls[0] = false;\n    n.walls[2] = false;\n  }\n\n}\n\nfunction getRandomIntInclusive(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","// import setupGrid from './grid.js';\nimport dfsGen from './generators/dfs.js';\nimport HumSolve from \"./solvers/human.js\";\nimport {SetupGrid} from './setup/grid.js';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n\n  const easyButton = document.getElementById('easy');\n  const mediumButton = document.getElementById('medium');\n  const hardButton = document.getElementById('hard');\n\n  easyButton.onclick = function() {\n    const grid = new SetupGrid(50);\n    dfsGen(grid, 50);\n  };\n  mediumButton.onclick = function() {\n    const grid = new SetupGrid(20);\n    dfsGen(grid, 20);\n  };\n  hardButton.onclick = function() {\n    const grid = new SetupGrid(10);\n    dfsGen(grid, 10);\n  };\n});\n","export default function Cell(i, j, w, ctx, grid, cols, rows) {\n  this.i = i;\n  this.j = j;\n  this.visited = false;\n  this.explored = false;\n  this.walls = [true, true, true, true];\n  this.target = false;\n  this.parent = null;\n\n  this.highlight = function(color) {\n    const x  = this.i*w;\n    const y = this.j*w;\n\n    ctx.fillStyle = color;\n    ctx.fillRect(x, y, w, w);\n  };\n\n  this.neighbours = function(status) {\n    const neighbours = [];\n\n    const top = grid[index(i, j-1, cols, rows)];\n    const right = grid[index(i+1, j, cols, rows)];\n    const bottom = grid[index(i, j+1, cols, rows)];\n    const left = grid[index(i-1, j, cols, rows)];\n\n    const cells = [top,right,bottom,left];\n\n    cells.forEach( cell => {\n      if (cell && status === 'visited'){\n        if (!cell.visited) {\n          neighbours.push(cell);\n        }\n      } else if (cell && status === 'explored'){\n        if (!cell.explored) {\n          neighbours.push(cell);\n        }\n      } else if (cell && status === 'human') {\n        neighbours.push(cell);\n      }\n    });\n\n    return neighbours;\n  };\n\n  this.show = function(color) {\n    const x  = this.i*w;\n    const y = this.j*w;\n\n\n    buildWalls(x, y, w, ctx, this.walls);\n\n    if (this.visited && !this.explored) {\n      ctx.fillStyle = 'red';\n      ctx.fillRect(x, y, w, w);\n      buildWalls(x, y, w, ctx, this.walls);\n    }\n\n    if (this.explored) {\n      ctx.fillStyle = color;\n      ctx.fillRect(x, y, w, w);\n      buildWalls(x, y, w, ctx, this.walls);\n    }\n  };\n}\n\nfunction index (i, j, cols, rows) {\n  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {\n    return -1;\n  }\n  return i + (j * cols);\n}\n\nfunction buildWalls(x, y, w, ctx, walls){\n\n  const wallfunc = [topWall, rightWall, bottomWall, leftWall];\n\n  [0,1,2,3].forEach(i=>{\n    if (walls[i]){\n      ctx.strokeStyle = 'white';\n      ctx.lineWidth = 2;\n      wallfunc[i](x, y, w, ctx);\n    }\n  });\n\n}\n\nfunction topWall(x, y, w, ctx) {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x+w, y);\n  ctx.stroke();\n\n}\n\nfunction rightWall(x, y, w, ctx){\n  ctx.beginPath();\n  ctx.moveTo(x+w, y);\n  ctx.lineTo(x+w, y+w);\n  ctx.stroke();\n\n}\n\nfunction bottomWall(x, y, w, ctx){\n  ctx.beginPath();\n  ctx.moveTo(x+w, (y+w));\n  ctx.lineTo(x, (y+w));\n  ctx.stroke();\n\n}\n\nfunction leftWall(x, y, w, ctx){\n  ctx.beginPath();\n  ctx.moveTo(x, y+w);\n  ctx.lineTo(x, y);\n  ctx.stroke();\n\n}\n","import Cell from './cell.js';\n\n\nexport function SetupGrid(width) {\n  this.mC = document.getElementById('myCanvas');\n  this.ctx = this.mC.getContext(\"2d\");\n  this.cWidth = this.mC.width;\n  this.cHeight = this.mC.height;\n\n  this.ctx.fillStyle = \"black\";\n  this.ctx.fillRect(0,0, this.cWidth, this.cHeight);\n\n  this.cols = Math.floor(this.cWidth/width);\n  this.rows = Math.floor(this.cHeight/width);\n  const grid = [];\n\n  for (let j = 0; j < this.rows; j++) {\n    for (let i = 0; i < this.cols; i++) {\n      const cell = new Cell(i, j, width, this.ctx, grid, this.cols, this.rows);\n      grid.push(cell);\n    }\n  }\n\n  return grid;\n}\n\nexport function draw (grid) {\n  for (let i = 0; i < grid.length; i++) {\n    grid[i].explored = false;\n    grid[i].show();\n    if (grid[i].target === true) {\n      grid[i].highlight('lightskyblue');\n    }\n  }\n\n}\n","import { draw } from '../setup/grid.js';\n\nexport default function bfsSolve(maze) {\n  const bfsSolButton = document.getElementById('bfs-sol');\n  bfsSolButton.disabled = true;\n\n  const dfsSolButton = document.getElementById('dfs-sol');\n  dfsSolButton.disabled = true;\n\n  const easyButton = document.getElementById('easy');\n  easyButton.disabled = true;\n  const mediumButton = document.getElementById('medium');\n  mediumButton.disabled = true;\n  const hardButton = document.getElementById('hard');\n  hardButton.disabled = true;\n\n  const humSolButton = document.getElementById('hum-sol');\n  humSolButton.disabled = true;\n\n  if (window.humanCallback) {\n    document.removeEventListener('keydown', window.humanCallback);\n  }\n\n  draw(maze);\n\n  const queue = [];\n  const exploredPaths = [];\n  let targetFound = false;\n  let color = 'green';\n  let neighbours;\n  let nextPaths;\n\n  let current = maze[0];\n  current.explored = true;\n\n  const interval =  setInterval( () => {\n\n    current.highlight(color);\n    current.show(color);\n\n    if (exploredPaths.length > 0){\n      exploredPaths.forEach( () => {\n        exploredPaths.pop().show(color);\n      });\n    }\n\n    if (targetFound === false) {\n       neighbours = current.neighbours(\"explored\");\n       nextPaths = selectNeighbour(current, neighbours);\n    }\n\n    if (nextPaths && targetFound === false) {\n      for (let i = 0; i < nextPaths.length; i++) {\n        nextPaths[i].highlight('yellow');\n        nextPaths[i].explored = true;\n        if (nextPaths[i].target === true){\n          targetFound = true;\n          color = 'blue';\n          nextPaths[i].highlight('lightskyblue');\n          nextPaths[i].show('lightskyblue');\n          current = nextPaths[i];\n          break;\n        } else {\n          exploredPaths.push(nextPaths[i]);\n          queue.push(nextPaths[i]);\n        }\n      }\n    }\n\n    if (targetFound === false) {\n      current = queue.shift();\n    }\n\n    if (targetFound === true) {\n      current = current.parent;\n      current.highlight('yellow');\n    }\n\n\n    if (current === maze[0]) {\n      clearInterval(interval);\n      easyButton.disabled = false;\n      mediumButton.disabled = false;\n      hardButton.disabled = false;\n      bfsSolButton.disabled = false;\n      dfsSolButton.disabled = false;\n      humSolButton.disabled = false;\n    }\n  }, 1);\n}\n\nfunction selectNeighbour (current, neighbours) {\n  const walls = current.walls;\n  const nextPaths = [];\n\n  neighbours.forEach( neighbour => {\n    const x = current.i - neighbour.i;\n    const y = current.j - neighbour.j;\n\n    if (x === -1 && !walls[1]) {\n      nextPaths.push(neighbour);\n    } else if (x === 1 && !walls[3]) {\n      nextPaths.push(neighbour);\n    }\n\n    if (y === -1 && !walls[2]) {\n      nextPaths.push(neighbour);\n    } else if (y === 1 && !walls[0]) {\n      nextPaths.push(neighbour);\n    }\n  });\n\n  return nextPaths;\n}\n","import { draw } from '../setup/grid.js';\n\nexport default function dfsSolve(maze) {\n  const dfsSolButton = document.getElementById('dfs-sol');\n  dfsSolButton.disabled = true;\n\n  const easyButton = document.getElementById('easy');\n  easyButton.disabled = true;\n  const mediumButton = document.getElementById('medium');\n  mediumButton.disabled = true;\n  const hardButton = document.getElementById('hard');\n  hardButton.disabled = true;\n\n  const bfsSolButton = document.getElementById('bfs-sol');\n  bfsSolButton.disabled = true;\n\n  const humSolButton = document.getElementById('hum-sol');\n  humSolButton.disabled = true;\n\n  if (window.humanCallback) {\n    document.removeEventListener('keydown', window.humanCallback);\n  }\n\n  draw(maze);\n\n  const stack = [];\n  let targetFound = false;\n  let color = 'green';\n  let neighbours;\n  let next;\n\n  let current = maze[0];\n  current.explored = true;\n\n  const interval =  setInterval( () => {\n    current.show(color);\n\n    if (current.target === true){\n      targetFound = true;\n      color = 'blue';\n      current.highlight('lightskyblue');\n      current.show('lightskyblue');\n    }\n\n    if (targetFound === false) {\n       neighbours = current.neighbours(\"explored\");\n       next = selectNeighbour(current, neighbours);\n    }\n\n    if (next && !next.explored) {\n      next.explored = true;\n      stack.push(current);\n      current.show(color);\n      next.highlight('yellow');\n      current = next;\n    } else if (stack.length > 0){\n      current = stack.pop();\n      current.highlight('yellow');\n      current.show(\"yellow\");\n    }\n\n    if (current === maze[0]) {\n      clearInterval(interval);\n      easyButton.disabled = false;\n      mediumButton.disabled = false;\n      hardButton.disabled = false;\n      dfsSolButton.disabled = false;\n      bfsSolButton.disabled = false;\n      humSolButton.disabled = false;\n    }\n  }, 1);\n}\n\nfunction selectNeighbour (current, neighbours) {\n  const walls = current.walls;\n  const nextPaths = [];\n\n  neighbours.forEach( neighbour => {\n    const x = current.i - neighbour.i;\n    const y = current.j - neighbour.j;\n\n    if (x === -1 && !walls[1]) {\n      nextPaths.push(neighbour);\n    } else if (x === 1 && !walls[3]) {\n      nextPaths.push(neighbour);\n    }\n\n    if (y === -1 && !walls[2]) {\n      nextPaths.push(neighbour);\n    } else if (y === 1 && !walls[0]) {\n      nextPaths.push(neighbour);\n    }\n  });\n\n  const random = getRandomIntInclusive(0, nextPaths.length-1);\n  return nextPaths[random];\n}\n\nfunction getRandomIntInclusive(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","import { draw } from '../setup/grid.js';\n\nexport default function HumSolve (maze) {\n\n  draw(maze);\n\n  let current = maze[0];\n  let previousPath = [];\n  let targetFound = false;\n\n  current.highlight('yellow');\n  current.explored = true;\n\n  window.humanCallback = (event) => {\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    let newCurrent = null;\n    switch (event.key) {\n      case \"ArrowDown\":\n        previousPath.push(current);\n        newCurrent = selectNeighbour(current, event.key);\n        if (newCurrent) {\n          current = newCurrent;\n          if (current.target === true) {\n            targetFound = true;\n            pathBack(current, window.humanCallback);\n          }\n          renderCurrent (current, previousPath);\n        } else {\n          document.removeEventListener('keydown', window.humanCallback);\n          new HumSolve (maze);\n        }\n        break;\n      case \"ArrowUp\":\n        previousPath.push(current);\n        newCurrent = selectNeighbour(current, event.key);\n        if (newCurrent) {\n          current = newCurrent;\n          if (current.target === true) {\n            targetFound = true;\n            pathBack(current, window.humanCallback);\n          }\n          renderCurrent (current, previousPath);\n        } else {\n          document.removeEventListener('keydown', window.humanCallback);\n          new HumSolve (maze);\n        }\n        break;\n      case \"ArrowLeft\":\n        previousPath.push(current);\n        newCurrent = selectNeighbour(current, event.key);\n        if (newCurrent) {\n          current = newCurrent;\n          if (current.target === true) {\n            targetFound = true;\n            pathBack(current, window.humanCallback);\n          }\n          renderCurrent (current, previousPath);\n        } else {\n          document.removeEventListener('keydown', window.humanCallback);\n          new HumSolve (maze);\n        }\n        break;\n      case \"ArrowRight\":\n        previousPath.push(current);\n        newCurrent = selectNeighbour(current, event.key);\n        if (newCurrent) {\n          current = newCurrent;\n          if (current.target === true) {\n            targetFound = true;\n            pathBack(current, window.humanCallback);\n          }\n          renderCurrent (current, previousPath);\n        } else {\n          document.removeEventListener('keydown', window.humanCallback);\n          new HumSolve (maze);\n        }\n        break;\n      default:\n        return;\n    }\n\n    event.preventDefault();\n  };\n\n  document.addEventListener(\"keydown\", window.humanCallback);\n}\n\nfunction renderCurrent (current, previousPath) {\n  if (current === undefined) {\n    return;\n  }\n  renderPrevious (previousPath);\n  current.explored = true;\n  current.highlight('yellow');\n}\n\nfunction renderPrevious (previous) {\n  if (previous.length > 0) {\n    previous.pop().show(\"green\");\n  }\n}\n\nfunction pathBack (current, callback) {\n  const interval = setInterval ( () => {\n    current.highlight(\"blue\");\n    current.show(\"blue\");\n\n    if (current.target === true) {\n      current.highlight('lightskyblue');\n      current.show('lightskyblue');\n    }\n    current = current.parent;\n    current.highlight('yellow');\n\n    if (current.parent === null) {\n      clearInterval(interval);\n      document.removeEventListener('keydown', callback);\n      console.log('removed');\n    }\n  }, 1);\n}\n\n\nfunction selectNeighbour (current, key) {\n  const neighbours = current.neighbours('human');\n  const walls = current.walls;\n  const nextPaths = [null, null, null, null];\n\n  neighbours.forEach( neighbour => {\n    const x = current.i - neighbour.i;\n    const y = current.j - neighbour.j;\n\n    if (x === -1 && !walls[1]) {\n      nextPaths[1] = neighbour;\n    } else if (x === 1 && !walls[3]) {\n      nextPaths[3] = neighbour;\n    }\n\n    if (y === -1 && !walls[2]) {\n      nextPaths[2] = neighbour;\n    } else if (y === 1 && !walls[0]) {\n      nextPaths[0] = neighbour;\n    }\n  });\n\n  switch (key) {\n    case \"ArrowUp\":\n      return nextPaths[0];\n    case \"ArrowRight\":\n      return nextPaths[1];\n    case \"ArrowDown\":\n      return nextPaths[2];\n    case \"ArrowLeft\":\n      return nextPaths[3];\n    default:\n      return;\n  }\n}\n\n\n\n// document.addEventListener('keyup', function (event) {\n//   if (event.defaultPrevented) {\n//       return;\n//   }\n//\n//   var key = event.key || event.keyCode;\n//\n//   if (key === 'Escape' || key === 'Esc' || key === 27) {\n//       doWhateverYouWantNowThatYourKeyWasHit();\n//   }\n// });\n"],"sourceRoot":""}