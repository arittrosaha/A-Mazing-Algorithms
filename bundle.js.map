{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./generators/dfs.js","webpack:///./main.js","webpack:///./setup/cell.js","webpack:///./setup/grid.js","webpack:///./solvers/dfs.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;ACnEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;AChFA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,CAAC;;;;;;;;;;;;;;;ACpBD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACtHA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./main.js\");\n","import SetupGrid from '../setup/grid.js';\n\nexport default function dfsGen (width, callback) {\n  const grid = new SetupGrid(width);\n  const stack = [];\n\n  const mC = document.getElementById('myCanvas');\n  const cWidth = mC.width;\n\n  const cols = Math.floor(cWidth/width);\n\n  let current = grid[0];\n  current.highlight('yellow');\n  current.visited = true;\n  const interval =  setInterval( () => {\n    current.show();\n\n    const neighbours = current.neighbours(\"visited\");\n    const next = selectNeighbour(neighbours);\n    if (next) {\n      next.visited = true;\n      stack.push(current);\n      removeWalls(current, next);\n      current.show();\n      next.show();\n      next.highlight('yellow');\n      current = next;\n    } else if (stack.length > 0){\n      current = stack.pop();\n      current.highlight('yellow');\n    }\n\n    if (current === grid[0]) {\n      clearInterval(interval);\n      current.show();\n\n      const min = grid.length-cols;\n      const max = grid.length-1;\n      const targetIdx = getRandomIntInclusive(min, max);\n      grid[targetIdx].target = true;\n      debugger;\n      grid[targetIdx].show('lightskyblue');\n      grid[targetIdx].highlight('lightskyblue');\n\n      callback(grid);\n    }\n  }, 1);\n}\n\nfunction selectNeighbour (neighbours) {\n  if (neighbours.length > 0) {\n    const random = getRandomIntInclusive(0, neighbours.length-1); // Math.floor(Math.random() * 10 % neighbours.length);\n    return neighbours[random];\n  }\n}\n\nfunction removeWalls(c, n) {\n  const x = c.i - n.i;\n  const y = c.j - n.j;\n\n  if (x === -1) {\n    c.walls[1] = false;\n    n.walls[3] = false;\n  } else if (x === 1) {\n    c.walls[3] = false;\n    n.walls[1] = false;\n  }\n\n  if (y === -1) {\n    c.walls[2] = false;\n    n.walls[0] = false;\n  } else if (y === 1) {\n    c.walls[0] = false;\n    n.walls[2] = false;\n  }\n\n}\n\nfunction getRandomIntInclusive(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n","// import setupGrid from './grid.js';\nimport dfsGen from './generators/dfs.js';\nimport dfsSolve from './solvers/dfs.js';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  // const genPromise = new Promise(function(resolve, reject) {\n  //   const maze = dfsGen(20);\n  //   if (maze.length === 625) {\n  //     resolve(maze);\n  //   } else {\n  //     reject(\"Something broke!\");\n  //   }\n  // });\n  //\n  // genPromise.then( maze => {\n  //   dfsSolve(maze);\n  //   console.log(maze);\n  // });\n\n  const maze = dfsGen(10, dfsSolve);\n});\n","export default function Cell(i, j, w, ctx, grid, cols, rows) {\n  this.i = i;\n  this.j = j;\n  this.visited = false;\n  this.explored = false;\n  this.walls = [true, true, true, true];\n  this.target = false;\n\n  this.highlight = function(color) {\n    const x  = this.i*w;\n    const y = this.j*w;\n\n    ctx.fillStyle = color;\n    ctx.fillRect(x, y, w, w);\n  };\n\n  this.neighbours = function(status) {\n    const neighbours = [];\n\n    const top = grid[index(i, j-1, cols, rows)];\n    const right = grid[index(i+1, j, cols, rows)];\n    const bottom = grid[index(i, j+1, cols, rows)];\n    const left = grid[index(i-1, j, cols, rows)];\n\n    const cells = [top,right,bottom,left];\n\n    cells.forEach( cell => {\n      if (cell && status === 'visited'){\n        if (!cell.visited) {\n          neighbours.push(cell);\n        }\n      } else if (cell && status === 'explored'){\n        if (!cell.explored) {\n          neighbours.push(cell);\n        }\n      }\n    });\n\n    return neighbours;\n  };\n\n  this.show = function(color) {\n    const x  = this.i*w;\n    const y = this.j*w;\n\n\n    // buildWalls(x, y, w, ctx, this.walls, 'white');\n\n    if (this.visited && !this.explored) {\n      buildWalls(x, y, w, ctx, this.walls, 'red');\n      ctx.fillStyle = 'red';\n      ctx.fillRect(x, y, w, w);\n    }\n\n    if (this.explored) {\n      // buildWalls(x, y, w, ctx, this.walls, 'black');\n      buildWalls(x, y, w, ctx, this.walls, color);\n      ctx.fillStyle = color;\n      ctx.fillRect(x, y, w, w);\n    }\n  };\n}\n\nfunction index (i, j, cols, rows) {\n  if (i < 0 || j < 0 || i > cols - 1 || j > rows - 1) {\n    return -1;\n  }\n  return i + (j * cols);\n}\n\nfunction buildWalls(x, y, w, ctx, walls, color){\n\n  const wallfunc = [topWall, rightWall, bottomWall, leftWall];\n\n  [0,1,2,3].forEach(i=>{\n    if (walls[i]){\n      ctx.strokeStyle = 'black';\n      ctx.lineWidth = 2;\n      wallfunc[i](x, y, w, ctx);\n    } else {\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 2;\n      wallfunc[i](x, y, w, ctx);\n    }\n  });\n\n}\n\nfunction topWall(x, y, w, ctx) {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  ctx.lineTo(x+w, y);\n  ctx.stroke();\n\n}\n\nfunction rightWall(x, y, w, ctx){\n  ctx.beginPath();\n  ctx.moveTo(x+w, y);\n  ctx.lineTo(x+w, y+w);\n  ctx.stroke();\n\n}\n\nfunction bottomWall(x, y, w, ctx){\n  ctx.beginPath();\n  ctx.moveTo(x+w, y+w);\n  ctx.lineTo(x, y+w);\n  ctx.stroke();\n\n}\n\nfunction leftWall(x, y, w, ctx){\n  ctx.beginPath();\n  ctx.moveTo(x, y+w);\n  ctx.lineTo(x, y);\n  ctx.stroke();\n\n}\n","import Cell from './cell.js';\n\n\nexport default function SetupGrid(width) {\n  this.mC = document.getElementById('myCanvas');\n  this.ctx = this.mC.getContext(\"2d\");\n  this.cWidth = this.mC.width;\n  this.cHeight = this.mC.height;\n\n  this.cols = Math.floor(this.cWidth/width);\n  this.rows = Math.floor(this.cHeight/width);\n  const grid = [];\n\n  for (let j = 0; j < this.rows; j++) {\n    for (let i = 0; i < this.cols; i++) {\n      const cell = new Cell(i, j, width, this.ctx, grid, this.cols, this.rows);\n      grid.push(cell);\n    }\n  }\n\n  draw(grid);\n  return grid;\n}\n\nfunction draw (grid) {\n  for (let i = 0; i < grid.length; i++) {\n    grid[i].show();\n  }\n\n}\n","\nexport default function dfsSolve(maze) {\n  const stack = [];\n  let targetFound = false;\n  let color = 'lightgreen';\n  let neighbours;\n  let next;\n\n  let current = maze[0];\n  current.explored = true;\n  const interval =  setInterval( () => {\n    current.show(color);\n\n    if (current.target === true){\n      targetFound = true;\n      color = 'green';\n      current.highlight('lightskyblue');\n      current.show('lightskyblue');\n    }\n\n    if (targetFound === false) {\n       neighbours = current.neighbours(\"explored\");\n       next = selectNeighbour(current, neighbours);\n    }\n\n    if (next && !next.explored) {\n      next.explored = true;\n      stack.push(current);\n      current.show('lightgreen');\n      next.highlight('yellow');\n      current = next;\n    } else if (stack.length > 0){\n      current = stack.pop();\n      current.highlight('yellow');\n      current.show(\"yellow\");\n    }\n\n    if (current === maze[0]) {\n      clearInterval(interval);\n    }\n  }, 1);\n}\n\nfunction selectNeighbour (current, neighbours) {\n  const walls = current.walls;\n  const nextPaths = [];\n\n  neighbours.forEach( neighbour => {\n    const x = current.i - neighbour.i;\n    const y = current.j - neighbour.j;\n\n    if (x === -1 && !walls[1]) {\n      nextPaths.push(neighbour);\n    } else if (x === 1 && !walls[3]) {\n      nextPaths.push(neighbour);\n    }\n\n    if (y === -1 && !walls[2]) {\n      nextPaths.push(neighbour);\n    } else if (y === 1 && !walls[0]) {\n      nextPaths.push(neighbour);\n    }\n  });\n\n  const random = getRandomIntInclusive(0, nextPaths.length-1);\n  return nextPaths[random];\n}\n\nfunction getRandomIntInclusive(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n"],"sourceRoot":""}